{"version":3,"sources":["../src/data_processor.js"],"names":["restructuredData","rowCols","rows","data","cols","reduce","arr","c","col","text","toLowerCase","push","i","length","row","serise","k","tailorData","influxUrl","utils","influxHost","sort","a","b","production_line","order_data","takeOfKeys","order_dimensions","lines","d","findDistinct","line_data","line","l","split","item","line_dimensions","positioning_dimensions","concat","index","matchIndex","positioning_data","categorisedOrders","categoriseByLineAndDate","promises","lineGroup","dateGroup","_startTime","STkey","dateGroupWithTime","filter","order","findIndex","undefined","dateGroupWithoutTime","wt","startTime","endtime","moment","isBefore","changeover_duration","duration","changeover_startTime","subtract","changeover","copyObject","valueOf","cons","STATE_CHANGEOVER","o","lineDefaultStartTime","getLineStartTime","currentStartTime","_endTime","add","writeLine","mergeKeyVal","post","Promise","all","then","chartCtrl","refreshDashb","catch","alert","e","_order_data","_order_dimensions","forEach","product_id_api","dimensions","key","map","Object","values","obj","result","elem","objdata","dates","order_date","Array","from","Set","dateIndex","array","indexOf","order_id","product_id","compl_qty","machine_state","getRid","status","product_desc","planned_changeover_time","order_qty","endTime","planned_rate","x","join","getColor","color","STATE_PLAN","STATE_READY","STATE_FLAG","STATE_PAUSE","STATE_COMPLETE","STATE_CLOSE","STATE_START","getData","mergeKeyArrayVal"],"mappings":"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","file":"data_processor.js","sourcesContent":["import * as utils from './utils'\nimport * as cons from './constans'\nimport moment from 'moment'\nimport * as chartCtrl from './chart_ctrl'\n\nlet _order_data\nlet _order_dimensions\n\n/**\n * Expecting columns names, and rows values\n * Return {col-1 : value-1, col-2 : value-2 .....}\n * @param {*} rowCols \n * @param {*} rows \n */\nexport function restructuredData (rowCols, rows) {\n  let data = []\n  let cols = rowCols.reduce((arr, c) => {\n    const col = c.text.toLowerCase()\n    arr.push(col)\n    return arr\n  }, [])\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i]\n    let serise = {}\n    for (let k = 0; k < cols.length; k++) {\n      const col = cols[k]\n      serise[col] = row[k]\n    }\n    data.push(serise)\n  }\n\n  if (data.length === 0) {return []}  \n\n  return tailorData(data, rowCols)\n}\n\nfunction tailorData(data, rowCols) {\n  \n  //url for writing influxdb data\n  const influxUrl = utils.influxHost + 'write?db=smart_factory'\n\n  //sort\n  if (data.length > 1) {\n    data = data.sort((a, b) => (a.production_line > b.production_line) ? -1 : (a.production_line < b.production_line) ? 1 : 0)\n  }\n  \n  //make order_data and its dimensions\n  let order_data = takeOfKeys(data)\n \n  let order_dimensions = rowCols.reduce((arr, col) => {\n    arr.push(col.text.toLowerCase())\n    return arr\n  }, [])\n\n  //find distinct lines\n  let lines = data.reduce((arr, d) => {\n    arr.push(d.production_line)\n    return arr\n  }, [])\n  lines = utils.findDistinct(lines)\n\n  //make line_data to match the dimension, which is expected by the chart option data\n  let line_data = []\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const l = line.split(' | ')\n    const item = [l[0] + ' | ' + l[1], l[2], i, line]\n    line_data.push(item)\n  }\n  \n  let line_dimensions = ['SiteArea', 'Line', 'Index', 'ProductionLine']\n\n  //add elems to the dimension, which are expected by the option\n  const positioning_dimensions = ['index', 'startTime', 'endTime']\n  order_dimensions = positioning_dimensions.concat(order_dimensions)\n\n  //add elems to the order_data to match the dimension\n  for (let i = 0; i < order_data.length; i++) {\n    const d = data[i]\n    const index = matchIndex(d.production_line, line_data)\n    data[i][\"index\"] = index\n    const positioning_data = [index, 0, 0]\n    order_data[i] = positioning_data.concat(order_data[i])\n  }\n\n  //categorise the order_data, group by line, and in each lineGroup, group by date\n  const categorisedOrders = categoriseByLineAndDate(order_data, 'array', data)\n  //console.log(categorisedOrders)\n  let promises = []\n  for (let i = 0; i < categorisedOrders.length; i++) {\n    const lineGroup = categorisedOrders[i]\n    for (let c = 0; c < lineGroup.length; c++) {\n      const dateGroup = lineGroup[c];\n      let _startTime = 0\n      \n      //filter out two groups, one is with startTime initalised, one is not.\n      const STkey = 'scheduled_start_datetime'\n      const dateGroupWithTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] !== null && order[findIndex(STkey, order_dimensions)] !== undefined)\n      const dateGroupWithoutTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] === null || order[findIndex(STkey, order_dimensions)] === undefined)\n      \n      //loop thro the date group containing orders that are with time\n      for (let wt = 0; wt < dateGroupWithTime.length; wt++) {\n        const order = dateGroupWithTime[wt];\n        const startTime = order[findIndex(STkey, order_dimensions)]\n        const endtime = order[findIndex('scheduled_end_datetime', order_dimensions)]\n\n        if (_startTime === 0) {\n          _startTime = moment(endtime)\n        }else {\n          //start time has been initialised, check if the end time is after the initialised start time\n          if(_startTime.isBefore(moment(endtime))){\n            //if yes, update the starttime again\n            _startTime = moment(endtime)\n          }\n        }\n\n        //update order's startTime and endTime\n        order[findIndex(\"startTime\", order_dimensions)] = startTime\n        order[findIndex(\"endTime\", order_dimensions)] = endtime    \n        \n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          const changeover_startTime = moment(startTime).subtract(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[findIndex(\"endTime\", order_dimensions)] = startTime // changeover's end time = main order's start time\n          changeover[findIndex(\"startTime\", order_dimensions)] = changeover_startTime.valueOf() // changeover's start time = it's end time - it's changeover time\n          changeover[findIndex(\"status\", order_dimensions)] = cons.STATE_CHANGEOVER // set statuts to be changeover\n          order_data.push(changeover)\n        }\n      }\n\n      //console.log(dateGroupWithoutTime)\n\n      //loop thro the date group containing orders that are with NO time\n      for (let o = 0; o < dateGroupWithoutTime.length; o++) {\n        const order = dateGroupWithoutTime[o];\n        let lineDefaultStartTime = utils.getLineStartTime(order[findIndex('production_line', order_dimensions)])\n        //if there is no startTime, init it with the order_date and lineDefaultStartTime\n        if (_startTime === 0) {\n          _startTime = order[findIndex('order_date',order_dimensions)] + ' ' + lineDefaultStartTime\n          _startTime = moment(_startTime, 'YYYY-MM-DD H:mm:ss')\n        }\n\n        //get startTime, then calc the order's duration based on qty and rate, then calc the endTime\n        let currentStartTime = _startTime.valueOf()\n        let duration = order[findIndex('order_qty',order_dimensions)] / (order[findIndex('planned_rate',order_dimensions)] * 60)\n        let _endTime = _startTime.add(duration, 'hours')\n\n        //handle changeover\n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n\n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          let changeover = utils.copyObject(order)\n          // console.log('change_in', changeover)\n          // console.log('change_d_in', order_dimensions)\n          changeover[findIndex(\"startTime\", order_dimensions)] = currentStartTime // changeover's start time = current start time\n          changeover[findIndex(\"endTime\", order_dimensions)] = moment(currentStartTime).add(changeover_duration).valueOf() // changeover's end time = main order's start time\n          changeover[findIndex(\"status\", order_dimensions)] = cons.STATE_CHANGEOVER // set statuts to be changeover\n\n          order_data.push(changeover)\n\n          //update the order's startTime and endTime\n          order[findIndex(\"startTime\", order_dimensions)] = moment(currentStartTime).add(changeover_duration).valueOf()\n          order[findIndex(\"endTime\", order_dimensions)] = _endTime.add(changeover_duration).valueOf()\n        }else {\n          //update the order's startTime and endTime\n          order[findIndex(\"startTime\", order_dimensions)] = currentStartTime\n          order[findIndex(\"endTime\", order_dimensions)] = _endTime.valueOf()\n        }\n  \n        //update each order to the database\n        const line = writeLine(utils.mergeKeyVal(order, order_dimensions))\n        promises.push(utils.post(influxUrl, line))\n      }\n    }\n  }\n\n  if (promises.length > 0) {\n    //do nothing if requests are successful, popup the error if failed.\n    Promise.all(promises).then(res => {\n      chartCtrl.refreshDashb()\n    }).catch(e => {\n      utils.alert('error', 'Influxdb Error', 'An error occurred while updating data : ' + e)\n    })\n  }\n\n  //set order data and its dimension global because it will be required later from other files\n  _order_data = order_data\n  _order_dimensions = order_dimensions\n\n  // Echart automatically convert number String to Int, so need to add some extra non-num String to avoid this\n  // Will need to String.replace('###', '') when use it\n  order_data.forEach(e => {\n    const product_id_api = e[findIndex('product_id', order_dimensions)] + '###'\n    e.push(product_id_api)\n  })\n  order_dimensions.push('product_id_api')\n\n  //return the expect option data\n  return {\n    order: {data: order_data, dimensions: order_dimensions},\n    line: {data: line_data, dimensions: line_dimensions}\n  }\n}\n\nfunction matchIndex(key, lines){\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (key === line[3]) {\n      return line[2]\n    }\n  }\n  return -1\n}\n\nfunction takeOfKeys(data) {\n  return data.map( Object.values )\n}\n\n/**\n * Expecting an array of arrays, categorise the inner arrays by line\n */\nfunction categoriseByLineAndDate(data, key, obj){\n  let result = []\n  \n  for (let i = 0; i < data.length; i++) {\n    const elem = data[i];\n    const objdata = obj[i]\n    \n    let dates = obj.filter(d => d.production_line === objdata.production_line).map(d => d.order_date)\n    dates = Array.from(new Set(dates))\n    const dateIndex = findIndex(objdata.order_date, dates)\n    \n    if (result[objdata.index]) {\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }else {\n      result.push([])\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }\n  }\n\n  return result\n}\n\nexport function findIndex(key, array){\n  return array.indexOf(key)\n}\n\nfunction writeLine(data){  \n  //For influxdb tag keys, must add a forward slash \\ before each space   \n  // let product_desc = data.product_desc.split(' ').join('\\\\ ')\n  \n  let line = `OrderPerformance,order_id=${data.order_id},product_id=${data.product_id} `\n\n  if (data.compl_qty !== null && data.compl_qty !== undefined) {\n    line += 'compl_qty=' + data.compl_qty + ','\n  }\n  if (data.machine_state !== null && data.machine_state !== undefined) {\n    line += 'machine_state=\"' + getRid(data.machine_state) + '\"' + ','\n  }\n\n  line += 'order_state=\"' + getRid(data.status) + '\"' + ','\n  line += 'product_desc=\"' + getRid(data.product_desc) + '\"' + ','\n  line += 'order_date=\"' + data.order_date + '\"' + ','\n  line += 'production_line=\"' + getRid(data.production_line) + '\"' + ','\n  line += 'planned_changeover_time=\"' + data.planned_changeover_time + '\"' + ','\n  line += 'order_qty=' + data.order_qty + ','\n  line += 'scheduled_end_datetime=' + data.endTime + ','\n  line += 'scheduled_start_datetime=' + data.startTime + ','\n  line += 'setpoint_rate=' + 0 + ','\n  line += 'planned_rate=' + data.planned_rate\n\n  return line\n}\n\nfunction getRid(x) {\n  return x.split('\"').join('\\\\\"')\n}\n\nexport function getColor(status){\n  let color\n  switch (status.toLowerCase()) {\n    case cons.STATE_CHANGEOVER:\n      color = '#c9c52a'\n      break;\n    case cons.STATE_PLAN:\n      color = '#c9c9c9'\n      break;\n    case cons.STATE_READY:\n      color = '#CCFFAF'\n      break;\n    case cons.STATE_FLAG:\n      color = '#FFFB85'\n      break;\n    case cons.STATE_PAUSE:\n      color = '#E8B20C'\n      break;\n    case cons.STATE_COMPLETE:\n      color = '#70C6FF'\n      break;\n    case cons.STATE_CLOSE:\n      color = '#FF7773'\n      break;\n    case cons.STATE_START:\n      color = '#91F449'\n      break;\n    default:\n      color = '#fff'\n      break;\n  }\n  return color\n}\n\nexport function getData(){\n  return utils.mergeKeyArrayVal(_order_data, _order_dimensions).filter(order => order.status.toLowerCase() !== cons.STATE_CHANGEOVER)\n}"]}