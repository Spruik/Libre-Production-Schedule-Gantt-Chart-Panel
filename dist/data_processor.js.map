{"version":3,"sources":["../src/data_processor.js"],"names":["restructuredData","rowCols","rows","data","cols","reduce","arr","c","col","text","toLowerCase","push","i","length","row","serise","k","filterData","tailorData","filter","d","status","influxUrl","utils","influxHost","order_data","takeOfKeys","order_dimensions","lines","production_line","findDistinct","sort","line_data","line","l","split","item","line_dimensions","positioning_dimensions","concat","index","matchIndex","positioning_data","categorisedOrders","categoriseByLineAndDate","promises","lineGroup","dateGroup","_startTime","STkey","dateGroupWithTime","order","findIndex","undefined","dateGroupWithoutTime","wt","startTime","endtime","moment","isBefore","changeover_duration","duration","changeover_startTime","subtract","changeover","copyObject","valueOf","o","lineDefaultStartTime","getLineStartTime","currentStartTime","_endTime","add","writeLine","mergeKeyVal","post","Promise","all","then","catch","alert","e","_order_data","_order_dimensions","dimensions","key","map","Object","values","obj","result","elem","objdata","dates","order_date","Array","from","Set","dateIndex","array","indexOf","product_desc","join","order_id","product_id","compl_qty","planned_changeover_time","order_qty","endTime","planned_rate","getColor","color","getData","mergeKeyArrayVal"],"mappings":"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","file":"data_processor.js","sourcesContent":["import * as utils from './utils'\nimport moment from 'moment'\n\nlet _order_data\nlet _order_dimensions\n\n/**\n * Expecting columns names, and rows values\n * Return {col-1 : value-1, col-2 : value-2 .....}\n * @param {*} rowCols \n * @param {*} rows \n */\nexport function restructuredData (rowCols, rows) {\n  let data = []\n  let cols = rowCols.reduce((arr, c) => {\n    const col = c.text.toLowerCase()\n    arr.push(col)\n    return arr\n  }, [])\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i]\n    let serise = {}\n    for (let k = 0; k < cols.length; k++) {\n      const col = cols[k]\n      serise[col] = row[k]\n    }\n    data.push(serise)\n  }\n\n  data = filterData(data)\n  if (data.length === 0) {return []}  \n\n  return tailorData(data, rowCols)\n}\n\nfunction filterData(data){\n    return data.filter(d => d.status !== 'Deleted' && d.status !== 'Replaced')\n}\n\nfunction tailorData(data, rowCols) {\n  \n  //url for writing influxdb data\n  const influxUrl = utils.influxHost + 'write?db=smart_factory'\n\n  //make order_data and its dimensions\n  let order_data = takeOfKeys(data)\n  let order_dimensions = rowCols.reduce((arr, col) => {\n    arr.push(col.text.toLowerCase())\n    return arr\n  }, [])\n\n  //find distinct lines\n  let lines = data.reduce((arr, d) => {\n    arr.push(d.production_line)\n    return arr\n  }, [])\n  lines = utils.findDistinct(lines)\n  lines = lines.sort()  \n\n  //make line_data to match the dimension, which is expected by the chart option data\n  let line_data = []\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const l = line.split(' | ')\n    const item = [l[0] + ' | ' + l[1], l[2], i, line]\n    line_data.push(item)\n  }\n  let line_dimensions = ['SiteArea', 'Line', 'Index', 'ProductionLine']\n\n  //add elems to the dimension, which are expected by the option\n  const positioning_dimensions = ['index', 'startTime', 'endTime']\n  order_dimensions = positioning_dimensions.concat(order_dimensions)\n\n  //add elems to the order_data to match the dimension\n  for (let i = 0; i < order_data.length; i++) {\n    const d = data[i]\n    const index = matchIndex(d.production_line, line_data)\n    data[i][\"index\"] = index\n    const positioning_data = [index, 0, 0]\n    order_data[i] = positioning_data.concat(order_data[i])\n  }\n\n  //categorise the order_data, group by line, and in each lineGroup, group by date\n  const categorisedOrders = categoriseByLineAndDate(order_data, 'array', data)\n  \n  let promises = []\n  for (let i = 0; i < categorisedOrders.length; i++) {\n    const lineGroup = categorisedOrders[i]\n    for (let c = 0; c < lineGroup.length; c++) {\n      const dateGroup = lineGroup[c];\n      let _startTime = 0\n      \n\n      //filter out two groups, one is with startTime initalised, one is not.\n      const STkey = 'scheduled_start_datetime'\n      const dateGroupWithTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] !== null && order[findIndex(STkey, order_dimensions)] !== undefined)\n      const dateGroupWithoutTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] === null || order[findIndex(STkey, order_dimensions)] === undefined)\n      \n      //loop thro the date group containing orders that are with time\n      for (let wt = 0; wt < dateGroupWithTime.length; wt++) {\n        const order = dateGroupWithTime[wt];\n        const startTime = order[findIndex(STkey, order_dimensions)]\n        const endtime = order[findIndex('scheduled_end_datetime', order_dimensions)]\n\n        if (_startTime === 0) {\n          _startTime = moment(endtime)\n        }else {\n          //start time has been initialised, check if the end time is after the initialised start time\n          if(_startTime.isBefore(moment(endtime))){\n            //if yes, update the starttime again\n            _startTime = moment(endtime)\n          }\n        }\n\n        //update order's startTime and endTime\n        order[1] = startTime\n        order[2] = endtime    \n        \n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          const changeover_startTime = moment(startTime).subtract(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[2] = startTime // changeover's end time = main order's start time\n          changeover[1] = changeover_startTime.valueOf() // changeover's start time = it's end time - it's changeover time\n          changeover[8] = 'Changeover' // set statuts to be changeover\n          order_data.push(changeover)\n        }\n      }\n\n      //loop thro the date group containing orders that are with NO time\n      for (let o = 0; o < dateGroupWithoutTime.length; o++) {\n        const order = dateGroupWithoutTime[o];\n        let lineDefaultStartTime = utils.getLineStartTime(order[findIndex('production_line', order_dimensions)])\n        //if there is no startTime, init it with the order_date and lineDefaultStartTime\n        if (_startTime === 0) {\n          _startTime = order[findIndex('order_date',order_dimensions)] + ' ' + lineDefaultStartTime\n          _startTime = moment(_startTime, 'YYYY-MM-DD H:mm:ss')\n        }\n\n        //get startTime, then calc the order's duration based on qty and rate, then calc the endTime\n        let currentStartTime = _startTime.valueOf()\n        let duration = order[findIndex('order_qty',order_dimensions)] / order[findIndex('planned_rate',order_dimensions)]\n        let _endTime = _startTime.add(duration, 'hours')\n\n        //handle changeover\n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n\n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[1] = currentStartTime // changeover's start time = current start time\n          changeover[2] = moment(currentStartTime).add(changeover_duration).valueOf() // changeover's end time = main order's start time\n          changeover[8] = 'Changeover' // set statuts to be changeover\n\n          order_data.push(changeover)\n\n          //update the order's startTime and endTime\n          order[1] = moment(currentStartTime).add(changeover_duration).valueOf()\n          order[2] = _endTime.add(changeover_duration).valueOf()\n        }else {\n          //update the order's startTime and endTime\n          order[1] = currentStartTime\n          order[2] = _endTime.valueOf()\n        }\n  \n        //update each order to the database\n        const line = writeLine(utils.mergeKeyVal(order, order_dimensions))\n        promises.push(utils.post(influxUrl, line))\n      }\n    }\n  }\n\n  //do nothing if requests are successful, popup the error if failed.\n  Promise.all(promises).then().catch(e => {\n    utils.alert('error', 'Influxdb Error', 'An error occurred while updating data : ' + e)\n  })\n\n  //set order data and its dimension global because it will be required later from other files\n  _order_data = order_data\n  _order_dimensions = order_dimensions\n\n  //return the expect option data\n  return {\n    order: {data: order_data, dimensions: order_dimensions},\n    line: {data: line_data, dimensions: line_dimensions}\n  }\n}\n\nfunction matchIndex(key, lines){\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (key === line[3]) {\n      return line[2]\n    }\n  }\n  return -1\n}\n\nfunction takeOfKeys(data) {\n  return data.map( Object.values )\n}\n\n/**\n * Expecting an array of arrays, categorise the inner arrays by line\n */\nfunction categoriseByLineAndDate(data, key, obj){\n  let result = []\n  \n  for (let i = 0; i < data.length; i++) {\n    const elem = data[i];\n    const objdata = obj[i]\n     \n    let dates = obj.filter(d => d.production_line === objdata.production_line).map(d => d.order_date)\n    dates = Array.from(new Set(dates))\n    const dateIndex = findIndex(objdata.order_date, dates)\n\n    if (result[objdata.index]) {\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }else {\n      result.push([])\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }\n  }\n\n  return result\n}\n\nexport function findIndex(key, array){\n  return array.indexOf(key)\n}\n\nfunction writeLine(data){  \n  //For influxdb tag keys, must add a forward slash \\ before each space   \n  let product_desc = data.product_desc.split(' ').join('\\\\ ')\n  \n  let line = 'OrderPerformance,order_id=' + data.order_id + ',product_id=' + data.product_id + ',product_desc=' + product_desc + ' '\n\n  if (data.compl_qty !== null && data.compl_qty !== undefined) {\n    line += 'compl_qty=' + data.compl_qty + ','\n  }\n\n  line += 'order_state=\"' + data.status + '\"' + ','\n  line += 'order_date=\"' + data.order_date + '\"' + ','\n  line += 'production_line=\"' + data.production_line + '\"' + ','\n  line += 'planned_changeover_time=\"' + data.planned_changeover_time + '\"' + ','\n  line += 'order_qty=' + data.order_qty + ','\n  line += 'scheduled_end_datetime=' + data.endTime + ','\n  line += 'scheduled_start_datetime=' + data.startTime + ','\n  line += 'setpoint_rate=' + 0 + ','\n  line += 'planned_rate=' + data.planned_rate\n\n  return line\n}\n\nexport function getColor(status){\n  let color\n  switch (status) {\n    case 'Changeover':\n      color = '#c9c52a'\n      break;\n    case 'Planned':\n      color = '#c9c9c9'\n      break;\n    case 'Ready':\n      color = '#CCFFAF'\n      break;\n    case 'Next':\n      color = '#FFFB85'\n      break;\n    case 'Paused':\n      color = '#E8B20C'\n      break;\n    case 'Complete':\n      color = '#70C6FF'\n      break;\n    case 'Closed':\n      color = '#FF7773'\n      break;\n    case 'Running':\n      color = '#91F449'\n      break;\n    default:\n      color = '#fff'\n      break;\n  }\n  return color\n}\n\nexport function getData(){\n  return utils.mergeKeyArrayVal(_order_data, _order_dimensions).filter(order => order.status !== 'Changeover')\n}"]}