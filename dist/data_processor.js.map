{"version":3,"sources":["../src/data_processor.js"],"names":["restructuredData","rowCols","rows","data","cols","reduce","arr","c","col","text","toLowerCase","push","i","length","row","serise","k","tailorData","influxUrl","utils","influxHost","sort","a","b","production_line","order_data","takeOfKeys","order_dimensions","lines","d","findDistinct","line_data","line","l","split","item","line_dimensions","positioning_dimensions","concat","index","matchIndex","positioning_data","categorisedOrders","categoriseByLineAndDate","promises","lineGroup","dateGroup","_startTime","STkey","dateGroupWithTime","filter","order","findIndex","undefined","dateGroupWithoutTime","wt","startTime","endtime","moment","isBefore","changeover_duration","duration","changeover_startTime","subtract","changeover","copyObject","valueOf","cons","STATE_CHANGEOVER","o","lineDefaultStartTime","getLineStartTime","currentStartTime","console","log","_endTime","add","writeLine","mergeKeyVal","post","Promise","all","then","chartCtrl","refreshDashb","catch","alert","e","_order_data","_order_dimensions","forEach","product_id_api","dimensions","key","map","Object","values","obj","result","elem","objdata","dates","order_date","Array","from","Set","dateIndex","array","indexOf","product_desc","join","order_id","product_id","compl_qty","status","planned_changeover_time","order_qty","endTime","planned_rate","getColor","color","STATE_PLAN","STATE_READY","STATE_FLAG","STATE_PAUSE","STATE_COMPLETE","STATE_CLOSE","STATE_START","getData","mergeKeyArrayVal"],"mappings":"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","file":"data_processor.js","sourcesContent":["import * as utils from './utils'\nimport * as cons from './constans'\nimport moment from 'moment'\nimport * as chartCtrl from './chart_ctrl'\n\nlet _order_data\nlet _order_dimensions\n\n/**\n * Expecting columns names, and rows values\n * Return {col-1 : value-1, col-2 : value-2 .....}\n * @param {*} rowCols \n * @param {*} rows \n */\nexport function restructuredData (rowCols, rows) {\n  let data = []\n  let cols = rowCols.reduce((arr, c) => {\n    const col = c.text.toLowerCase()\n    arr.push(col)\n    return arr\n  }, [])\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i]\n    let serise = {}\n    for (let k = 0; k < cols.length; k++) {\n      const col = cols[k]\n      serise[col] = row[k]\n    }\n    data.push(serise)\n  }\n\n  if (data.length === 0) {return []}  \n\n  return tailorData(data, rowCols)\n}\n\nfunction tailorData(data, rowCols) {\n  \n  //url for writing influxdb data\n  const influxUrl = utils.influxHost + 'write?db=smart_factory'\n\n  //sort\n  if (data.length > 1) {\n    data = data.sort((a, b) => (a.production_line > b.production_line) ? -1 : (a.production_line < b.production_line) ? 1 : 0)\n  }\n  \n  //make order_data and its dimensions\n  let order_data = takeOfKeys(data)\n \n  let order_dimensions = rowCols.reduce((arr, col) => {\n    arr.push(col.text.toLowerCase())\n    return arr\n  }, [])\n\n  //find distinct lines\n  let lines = data.reduce((arr, d) => {\n    arr.push(d.production_line)\n    return arr\n  }, [])\n  lines = utils.findDistinct(lines)\n\n  //make line_data to match the dimension, which is expected by the chart option data\n  let line_data = []\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const l = line.split(' | ')\n    const item = [l[0] + ' | ' + l[1], l[2], i, line]\n    line_data.push(item)\n  }\n  \n  let line_dimensions = ['SiteArea', 'Line', 'Index', 'ProductionLine']\n\n  //add elems to the dimension, which are expected by the option\n  const positioning_dimensions = ['index', 'startTime', 'endTime']\n  order_dimensions = positioning_dimensions.concat(order_dimensions)\n\n  //add elems to the order_data to match the dimension\n  for (let i = 0; i < order_data.length; i++) {\n    const d = data[i]\n    const index = matchIndex(d.production_line, line_data)\n    data[i][\"index\"] = index\n    const positioning_data = [index, 0, 0]\n    order_data[i] = positioning_data.concat(order_data[i])\n  }\n\n  //categorise the order_data, group by line, and in each lineGroup, group by date\n  const categorisedOrders = categoriseByLineAndDate(order_data, 'array', data)\n  //console.log(categorisedOrders)\n  let promises = []\n  for (let i = 0; i < categorisedOrders.length; i++) {\n    const lineGroup = categorisedOrders[i]\n    for (let c = 0; c < lineGroup.length; c++) {\n      const dateGroup = lineGroup[c];\n      let _startTime = 0\n      \n      //filter out two groups, one is with startTime initalised, one is not.\n      const STkey = 'scheduled_start_datetime'\n      const dateGroupWithTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] !== null && order[findIndex(STkey, order_dimensions)] !== undefined)\n      const dateGroupWithoutTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] === null || order[findIndex(STkey, order_dimensions)] === undefined)\n      \n      //loop thro the date group containing orders that are with time\n      for (let wt = 0; wt < dateGroupWithTime.length; wt++) {\n        const order = dateGroupWithTime[wt];\n        const startTime = order[findIndex(STkey, order_dimensions)]\n        const endtime = order[findIndex('scheduled_end_datetime', order_dimensions)]\n\n        if (_startTime === 0) {\n          _startTime = moment(endtime)\n        }else {\n          //start time has been initialised, check if the end time is after the initialised start time\n          if(_startTime.isBefore(moment(endtime))){\n            //if yes, update the starttime again\n            _startTime = moment(endtime)\n          }\n        }\n\n        //update order's startTime and endTime\n        order[1] = startTime\n        order[2] = endtime    \n        \n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          const changeover_startTime = moment(startTime).subtract(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[2] = startTime // changeover's end time = main order's start time\n          changeover[1] = changeover_startTime.valueOf() // changeover's start time = it's end time - it's changeover time\n          changeover[8] = cons.STATE_CHANGEOVER // set statuts to be changeover\n          order_data.push(changeover)\n        }\n      }\n\n      //console.log(dateGroupWithoutTime)\n\n      //loop thro the date group containing orders that are with NO time\n      for (let o = 0; o < dateGroupWithoutTime.length; o++) {\n        const order = dateGroupWithoutTime[o];\n        let lineDefaultStartTime = utils.getLineStartTime(order[findIndex('production_line', order_dimensions)])\n        //if there is no startTime, init it with the order_date and lineDefaultStartTime\n        if (_startTime === 0) {\n          _startTime = order[findIndex('order_date',order_dimensions)] + ' ' + lineDefaultStartTime\n          _startTime = moment(_startTime, 'YYYY-MM-DD H:mm:ss')\n        }\n\n        //get startTime, then calc the order's duration based on qty and rate, then calc the endTime\n        let currentStartTime = _startTime.valueOf()\n        let duration = order[findIndex('order_qty',order_dimensions)] / (order[findIndex('planned_rate',order_dimensions)] * 60)\n        console.log(duration)\n        let _endTime = _startTime.add(duration, 'hours')\n\n        //handle changeover\n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n\n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[1] = currentStartTime // changeover's start time = current start time\n          changeover[2] = moment(currentStartTime).add(changeover_duration).valueOf() // changeover's end time = main order's start time\n          changeover[8] = cons.STATE_CHANGEOVER // set statuts to be changeover\n\n          order_data.push(changeover)\n\n          //update the order's startTime and endTime\n          order[1] = moment(currentStartTime).add(changeover_duration).valueOf()\n          order[2] = _endTime.add(changeover_duration).valueOf()\n        }else {\n          //update the order's startTime and endTime\n          order[1] = currentStartTime\n          order[2] = _endTime.valueOf()\n        }\n  \n        //update each order to the database\n        const line = writeLine(utils.mergeKeyVal(order, order_dimensions))\n        promises.push(utils.post(influxUrl, line))\n      }\n    }\n  }\n\n  if (promises.length > 0) {\n    //do nothing if requests are successful, popup the error if failed.\n    Promise.all(promises).then(res => {\n      chartCtrl.refreshDashb()\n    }).catch(e => {\n      utils.alert('error', 'Influxdb Error', 'An error occurred while updating data : ' + e)\n    })\n  }\n\n  //set order data and its dimension global because it will be required later from other files\n  _order_data = order_data\n  _order_dimensions = order_dimensions\n\n  // Echart automatically convert number String to Int, so need to add some extra non-num String to avoid this\n  // Will need to String.replace('###', '') when use it\n  order_data.forEach(e => {\n    const product_id_api = e[findIndex('product_id', order_dimensions)] + '###'\n    e.push(product_id_api)\n  })\n  order_dimensions.push('product_id_api')\n\n  //return the expect option data\n  return {\n    order: {data: order_data, dimensions: order_dimensions},\n    line: {data: line_data, dimensions: line_dimensions}\n  }\n}\n\nfunction matchIndex(key, lines){\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (key === line[3]) {\n      return line[2]\n    }\n  }\n  return -1\n}\n\nfunction takeOfKeys(data) {\n  return data.map( Object.values )\n}\n\n/**\n * Expecting an array of arrays, categorise the inner arrays by line\n */\nfunction categoriseByLineAndDate(data, key, obj){\n  let result = []\n  \n  for (let i = 0; i < data.length; i++) {\n    const elem = data[i];\n    const objdata = obj[i]\n    \n    let dates = obj.filter(d => d.production_line === objdata.production_line).map(d => d.order_date)\n    dates = Array.from(new Set(dates))\n    const dateIndex = findIndex(objdata.order_date, dates)\n    \n    if (result[objdata.index]) {\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }else {\n      result.push([])\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }\n  }\n\n  return result\n}\n\nexport function findIndex(key, array){\n  return array.indexOf(key)\n}\n\nfunction writeLine(data){  \n  //For influxdb tag keys, must add a forward slash \\ before each space   \n  let product_desc = data.product_desc.split(' ').join('\\\\ ')\n  \n  let line = 'OrderPerformance,order_id=' + data.order_id + ',product_id=' + data.product_id + ',product_desc=' + product_desc + ' '\n\n  if (data.compl_qty !== null && data.compl_qty !== undefined) {\n    line += 'compl_qty=' + data.compl_qty + ','\n  }\n\n  line += 'order_state=\"' + data.status + '\"' + ','\n  line += 'order_date=\"' + data.order_date + '\"' + ','\n  line += 'production_line=\"' + data.production_line + '\"' + ','\n  line += 'planned_changeover_time=\"' + data.planned_changeover_time + '\"' + ','\n  line += 'order_qty=' + data.order_qty + ','\n  line += 'scheduled_end_datetime=' + data.endTime + ','\n  line += 'scheduled_start_datetime=' + data.startTime + ','\n  line += 'setpoint_rate=' + 0 + ','\n  line += 'planned_rate=' + data.planned_rate\n\n  return line\n}\n\nexport function getColor(status){\n  let color\n  switch (status.toLowerCase()) {\n    case cons.STATE_CHANGEOVER:\n      color = '#c9c52a'\n      break;\n    case cons.STATE_PLAN:\n      color = '#c9c9c9'\n      break;\n    case cons.STATE_READY:\n      color = '#CCFFAF'\n      break;\n    case cons.STATE_FLAG:\n      color = '#FFFB85'\n      break;\n    case cons.STATE_PAUSE:\n      color = '#E8B20C'\n      break;\n    case cons.STATE_COMPLETE:\n      color = '#70C6FF'\n      break;\n    case cons.STATE_CLOSE:\n      color = '#FF7773'\n      break;\n    case cons.STATE_START:\n      color = '#91F449'\n      break;\n    default:\n      color = '#fff'\n      break;\n  }\n  return color\n}\n\nexport function getData(){\n  return utils.mergeKeyArrayVal(_order_data, _order_dimensions).filter(order => order.status.toLowerCase() !== cons.STATE_CHANGEOVER)\n}"]}