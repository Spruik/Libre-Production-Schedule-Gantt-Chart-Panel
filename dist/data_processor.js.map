{"version":3,"sources":["../src/data_processor.js"],"names":["restructuredData","rowCols","rows","data","cols","reduce","arr","c","col","text","toLowerCase","push","i","length","row","serise","k","filterData","tailorData","filter","d","status","influxUrl","utils","influxHost","sort","a","b","production_line","order_data","takeOfKeys","order_dimensions","lines","findDistinct","line_data","line","l","split","item","line_dimensions","positioning_dimensions","concat","index","matchIndex","positioning_data","categorisedOrders","categoriseByLineAndDate","promises","lineGroup","dateGroup","_startTime","STkey","dateGroupWithTime","order","findIndex","undefined","dateGroupWithoutTime","wt","startTime","endtime","moment","isBefore","changeover_duration","duration","changeover_startTime","subtract","changeover","copyObject","valueOf","o","lineDefaultStartTime","getLineStartTime","currentStartTime","_endTime","add","writeLine","mergeKeyVal","post","Promise","all","then","chartCtrl","refreshDashb","catch","alert","e","_order_data","_order_dimensions","dimensions","key","map","Object","values","obj","result","elem","objdata","dates","order_date","Array","from","Set","dateIndex","array","indexOf","product_desc","join","order_id","product_id","compl_qty","planned_changeover_time","order_qty","endTime","planned_rate","getColor","color","getData","mergeKeyArrayVal"],"mappings":"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","file":"data_processor.js","sourcesContent":["import * as utils from './utils'\nimport moment from 'moment'\nimport * as chartCtrl from './chart_ctrl'\n\nlet _order_data\nlet _order_dimensions\n\n/**\n * Expecting columns names, and rows values\n * Return {col-1 : value-1, col-2 : value-2 .....}\n * @param {*} rowCols \n * @param {*} rows \n */\nexport function restructuredData (rowCols, rows) {\n  let data = []\n  let cols = rowCols.reduce((arr, c) => {\n    const col = c.text.toLowerCase()\n    arr.push(col)\n    return arr\n  }, [])\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i]\n    let serise = {}\n    for (let k = 0; k < cols.length; k++) {\n      const col = cols[k]\n      serise[col] = row[k]\n    }\n    data.push(serise)\n  }\n\n  data = filterData(data)\n  if (data.length === 0) {return []}  \n\n  return tailorData(data, rowCols)\n}\n\nfunction filterData(data){\n    return data.filter(d => d.status !== 'Deleted' && d.status !== 'Replaced')\n}\n\nfunction tailorData(data, rowCols) {\n  \n  //url for writing influxdb data\n  const influxUrl = utils.influxHost + 'write?db=smart_factory'\n\n  //sort\n  if (data.length > 1) {\n    data = data.sort((a, b) => (a.production_line > b.production_line) ? -1 : (a.production_line < b.production_line) ? 1 : 0)\n  }\n  \n  //make order_data and its dimensions\n  let order_data = takeOfKeys(data)\n \n  let order_dimensions = rowCols.reduce((arr, col) => {\n    arr.push(col.text.toLowerCase())\n    return arr\n  }, [])\n\n  //find distinct lines\n  let lines = data.reduce((arr, d) => {\n    arr.push(d.production_line)\n    return arr\n  }, [])\n  lines = utils.findDistinct(lines)\n\n  //make line_data to match the dimension, which is expected by the chart option data\n  let line_data = []\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const l = line.split(' | ')\n    const item = [l[0] + ' | ' + l[1], l[2], i, line]\n    line_data.push(item)\n  }\n  \n  let line_dimensions = ['SiteArea', 'Line', 'Index', 'ProductionLine']\n\n  //add elems to the dimension, which are expected by the option\n  const positioning_dimensions = ['index', 'startTime', 'endTime']\n  order_dimensions = positioning_dimensions.concat(order_dimensions)\n\n  //add elems to the order_data to match the dimension\n  for (let i = 0; i < order_data.length; i++) {\n    const d = data[i]\n    const index = matchIndex(d.production_line, line_data)\n    data[i][\"index\"] = index\n    const positioning_data = [index, 0, 0]\n    order_data[i] = positioning_data.concat(order_data[i])\n  }\n\n  //categorise the order_data, group by line, and in each lineGroup, group by date\n  const categorisedOrders = categoriseByLineAndDate(order_data, 'array', data)\n  \n  let promises = []\n  for (let i = 0; i < categorisedOrders.length; i++) {\n    const lineGroup = categorisedOrders[i]\n    for (let c = 0; c < lineGroup.length; c++) {\n      const dateGroup = lineGroup[c];\n      let _startTime = 0\n      \n      //filter out two groups, one is with startTime initalised, one is not.\n      const STkey = 'scheduled_start_datetime'\n      const dateGroupWithTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] !== null && order[findIndex(STkey, order_dimensions)] !== undefined)\n      const dateGroupWithoutTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] === null || order[findIndex(STkey, order_dimensions)] === undefined)\n      \n      //loop thro the date group containing orders that are with time\n      for (let wt = 0; wt < dateGroupWithTime.length; wt++) {\n        const order = dateGroupWithTime[wt];\n        const startTime = order[findIndex(STkey, order_dimensions)]\n        const endtime = order[findIndex('scheduled_end_datetime', order_dimensions)]\n\n        if (_startTime === 0) {\n          _startTime = moment(endtime)\n        }else {\n          //start time has been initialised, check if the end time is after the initialised start time\n          if(_startTime.isBefore(moment(endtime))){\n            //if yes, update the starttime again\n            _startTime = moment(endtime)\n          }\n        }\n\n        //update order's startTime and endTime\n        order[1] = startTime\n        order[2] = endtime    \n        \n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          const changeover_startTime = moment(startTime).subtract(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[2] = startTime // changeover's end time = main order's start time\n          changeover[1] = changeover_startTime.valueOf() // changeover's start time = it's end time - it's changeover time\n          changeover[8] = 'Changeover' // set statuts to be changeover\n          order_data.push(changeover)\n        }\n      }\n\n      //loop thro the date group containing orders that are with NO time\n      for (let o = 0; o < dateGroupWithoutTime.length; o++) {\n        const order = dateGroupWithoutTime[o];\n        let lineDefaultStartTime = utils.getLineStartTime(order[findIndex('production_line', order_dimensions)])\n        //if there is no startTime, init it with the order_date and lineDefaultStartTime\n        if (_startTime === 0) {\n          _startTime = order[findIndex('order_date',order_dimensions)] + ' ' + lineDefaultStartTime\n          _startTime = moment(_startTime, 'YYYY-MM-DD H:mm:ss')\n        }\n\n        //get startTime, then calc the order's duration based on qty and rate, then calc the endTime\n        let currentStartTime = _startTime.valueOf()\n        let duration = order[findIndex('order_qty',order_dimensions)] / order[findIndex('planned_rate',order_dimensions)]\n        let _endTime = _startTime.add(duration, 'hours')\n\n        //handle changeover\n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n\n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[1] = currentStartTime // changeover's start time = current start time\n          changeover[2] = moment(currentStartTime).add(changeover_duration).valueOf() // changeover's end time = main order's start time\n          changeover[8] = 'Changeover' // set statuts to be changeover\n\n          order_data.push(changeover)\n\n          //update the order's startTime and endTime\n          order[1] = moment(currentStartTime).add(changeover_duration).valueOf()\n          order[2] = _endTime.add(changeover_duration).valueOf()\n        }else {\n          //update the order's startTime and endTime\n          order[1] = currentStartTime\n          order[2] = _endTime.valueOf()\n        }\n  \n        //update each order to the database\n        const line = writeLine(utils.mergeKeyVal(order, order_dimensions))\n        promises.push(utils.post(influxUrl, line))\n      }\n    }\n  }\n\n  if (promises.length > 0) {\n    //do nothing if requests are successful, popup the error if failed.\n    Promise.all(promises).then(res => {\n      chartCtrl.refreshDashb()\n    }).catch(e => {\n      utils.alert('error', 'Influxdb Error', 'An error occurred while updating data : ' + e)\n    })\n  }\n\n  //set order data and its dimension global because it will be required later from other files\n  _order_data = order_data\n  _order_dimensions = order_dimensions\n\n  //return the expect option data\n  return {\n    order: {data: order_data, dimensions: order_dimensions},\n    line: {data: line_data, dimensions: line_dimensions}\n  }\n}\n\nfunction matchIndex(key, lines){\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (key === line[3]) {\n      return line[2]\n    }\n  }\n  return -1\n}\n\nfunction takeOfKeys(data) {\n  return data.map( Object.values )\n}\n\n/**\n * Expecting an array of arrays, categorise the inner arrays by line\n */\nfunction categoriseByLineAndDate(data, key, obj){\n  let result = []\n  \n  for (let i = 0; i < data.length; i++) {\n    const elem = data[i];\n    const objdata = obj[i]\n    \n    let dates = obj.filter(d => d.production_line === objdata.production_line).map(d => d.order_date)\n    dates = Array.from(new Set(dates))\n    const dateIndex = findIndex(objdata.order_date, dates)\n    \n    if (result[objdata.index]) {\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }else {\n      result.push([])\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }\n  }\n\n  return result\n}\n\nexport function findIndex(key, array){\n  return array.indexOf(key)\n}\n\nfunction writeLine(data){  \n  //For influxdb tag keys, must add a forward slash \\ before each space   \n  let product_desc = data.product_desc.split(' ').join('\\\\ ')\n  \n  let line = 'OrderPerformance,order_id=' + data.order_id + ',product_id=' + data.product_id + ',product_desc=' + product_desc + ' '\n\n  if (data.compl_qty !== null && data.compl_qty !== undefined) {\n    line += 'compl_qty=' + data.compl_qty + ','\n  }\n\n  line += 'order_state=\"' + data.status + '\"' + ','\n  line += 'order_date=\"' + data.order_date + '\"' + ','\n  line += 'production_line=\"' + data.production_line + '\"' + ','\n  line += 'planned_changeover_time=\"' + data.planned_changeover_time + '\"' + ','\n  line += 'order_qty=' + data.order_qty + ','\n  line += 'scheduled_end_datetime=' + data.endTime + ','\n  line += 'scheduled_start_datetime=' + data.startTime + ','\n  line += 'setpoint_rate=' + 0 + ','\n  line += 'planned_rate=' + data.planned_rate\n\n  return line\n}\n\nexport function getColor(status){\n  let color\n  switch (status) {\n    case 'Changeover':\n      color = '#c9c52a'\n      break;\n    case 'Planned':\n      color = '#c9c9c9'\n      break;\n    case 'Ready':\n      color = '#CCFFAF'\n      break;\n    case 'Next':\n      color = '#FFFB85'\n      break;\n    case 'Paused':\n      color = '#E8B20C'\n      break;\n    case 'Complete':\n      color = '#70C6FF'\n      break;\n    case 'Closed':\n      color = '#FF7773'\n      break;\n    case 'Running':\n      color = '#91F449'\n      break;\n    default:\n      color = '#fff'\n      break;\n  }\n  return color\n}\n\nexport function getData(){\n  return utils.mergeKeyArrayVal(_order_data, _order_dimensions).filter(order => order.status !== 'Changeover')\n}"]}