{"version":3,"sources":["../src/data_processor.js"],"names":["restructuredData","rowCols","rows","data","cols","reduce","arr","c","col","text","toLowerCase","push","i","length","row","serise","k","tailorData","influxUrl","utils","influxHost","sort","a","b","production_line","order_data","takeOfKeys","order_dimensions","lines","d","findDistinct","line_data","line","l","split","item","line_dimensions","positioning_dimensions","concat","index","matchIndex","positioning_data","categorisedOrders","categoriseByLineAndDate","promises","lineGroup","dateGroup","_startTime","STkey","dateGroupWithTime","filter","order","findIndex","undefined","dateGroupWithoutTime","wt","startTime","endtime","moment","isBefore","changeover_duration","duration","changeover_startTime","subtract","changeover","copyObject","valueOf","o","lineDefaultStartTime","getLineStartTime","currentStartTime","_endTime","add","writeLine","mergeKeyVal","post","Promise","all","then","chartCtrl","refreshDashb","catch","alert","e","_order_data","_order_dimensions","forEach","product_id_api","dimensions","key","map","Object","values","obj","result","elem","objdata","dates","order_date","Array","from","Set","dateIndex","array","indexOf","product_desc","join","order_id","product_id","compl_qty","status","planned_changeover_time","order_qty","endTime","planned_rate","getColor","color","getData","mergeKeyArrayVal"],"mappings":"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","file":"data_processor.js","sourcesContent":["import * as utils from './utils'\nimport moment from 'moment'\nimport * as chartCtrl from './chart_ctrl'\n\nlet _order_data\nlet _order_dimensions\n\n/**\n * Expecting columns names, and rows values\n * Return {col-1 : value-1, col-2 : value-2 .....}\n * @param {*} rowCols \n * @param {*} rows \n */\nexport function restructuredData (rowCols, rows) {\n  let data = []\n  let cols = rowCols.reduce((arr, c) => {\n    const col = c.text.toLowerCase()\n    arr.push(col)\n    return arr\n  }, [])\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i]\n    let serise = {}\n    for (let k = 0; k < cols.length; k++) {\n      const col = cols[k]\n      serise[col] = row[k]\n    }\n    data.push(serise)\n  }\n\n  if (data.length === 0) {return []}  \n\n  return tailorData(data, rowCols)\n}\n\nfunction tailorData(data, rowCols) {\n  \n  //url for writing influxdb data\n  const influxUrl = utils.influxHost + 'write?db=smart_factory'\n\n  //sort\n  if (data.length > 1) {\n    data = data.sort((a, b) => (a.production_line > b.production_line) ? -1 : (a.production_line < b.production_line) ? 1 : 0)\n  }\n  \n  //make order_data and its dimensions\n  let order_data = takeOfKeys(data)\n \n  let order_dimensions = rowCols.reduce((arr, col) => {\n    arr.push(col.text.toLowerCase())\n    return arr\n  }, [])\n\n  //find distinct lines\n  let lines = data.reduce((arr, d) => {\n    arr.push(d.production_line)\n    return arr\n  }, [])\n  lines = utils.findDistinct(lines)\n\n  //make line_data to match the dimension, which is expected by the chart option data\n  let line_data = []\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const l = line.split(' | ')\n    const item = [l[0] + ' | ' + l[1], l[2], i, line]\n    line_data.push(item)\n  }\n  \n  let line_dimensions = ['SiteArea', 'Line', 'Index', 'ProductionLine']\n\n  //add elems to the dimension, which are expected by the option\n  const positioning_dimensions = ['index', 'startTime', 'endTime']\n  order_dimensions = positioning_dimensions.concat(order_dimensions)\n\n  //add elems to the order_data to match the dimension\n  for (let i = 0; i < order_data.length; i++) {\n    const d = data[i]\n    const index = matchIndex(d.production_line, line_data)\n    data[i][\"index\"] = index\n    const positioning_data = [index, 0, 0]\n    order_data[i] = positioning_data.concat(order_data[i])\n  }\n\n  //categorise the order_data, group by line, and in each lineGroup, group by date\n  const categorisedOrders = categoriseByLineAndDate(order_data, 'array', data)\n  \n  let promises = []\n  for (let i = 0; i < categorisedOrders.length; i++) {\n    const lineGroup = categorisedOrders[i]\n    for (let c = 0; c < lineGroup.length; c++) {\n      const dateGroup = lineGroup[c];\n      let _startTime = 0\n      \n      //filter out two groups, one is with startTime initalised, one is not.\n      const STkey = 'scheduled_start_datetime'\n      const dateGroupWithTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] !== null && order[findIndex(STkey, order_dimensions)] !== undefined)\n      const dateGroupWithoutTime = dateGroup.filter(order => order[findIndex(STkey, order_dimensions)] === null || order[findIndex(STkey, order_dimensions)] === undefined)\n      \n      //loop thro the date group containing orders that are with time\n      for (let wt = 0; wt < dateGroupWithTime.length; wt++) {\n        const order = dateGroupWithTime[wt];\n        const startTime = order[findIndex(STkey, order_dimensions)]\n        const endtime = order[findIndex('scheduled_end_datetime', order_dimensions)]\n\n        if (_startTime === 0) {\n          _startTime = moment(endtime)\n        }else {\n          //start time has been initialised, check if the end time is after the initialised start time\n          if(_startTime.isBefore(moment(endtime))){\n            //if yes, update the starttime again\n            _startTime = moment(endtime)\n          }\n        }\n\n        //update order's startTime and endTime\n        order[1] = startTime\n        order[2] = endtime    \n        \n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          const changeover_startTime = moment(startTime).subtract(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[2] = startTime // changeover's end time = main order's start time\n          changeover[1] = changeover_startTime.valueOf() // changeover's start time = it's end time - it's changeover time\n          changeover[8] = 'Changeover' // set statuts to be changeover\n          order_data.push(changeover)\n        }\n      }\n\n      //loop thro the date group containing orders that are with NO time\n      for (let o = 0; o < dateGroupWithoutTime.length; o++) {\n        const order = dateGroupWithoutTime[o];\n        let lineDefaultStartTime = utils.getLineStartTime(order[findIndex('production_line', order_dimensions)])\n        //if there is no startTime, init it with the order_date and lineDefaultStartTime\n        if (_startTime === 0) {\n          _startTime = order[findIndex('order_date',order_dimensions)] + ' ' + lineDefaultStartTime\n          _startTime = moment(_startTime, 'YYYY-MM-DD H:mm:ss')\n        }\n\n        //get startTime, then calc the order's duration based on qty and rate, then calc the endTime\n        let currentStartTime = _startTime.valueOf()\n        let duration = order[findIndex('order_qty',order_dimensions)] / order[findIndex('planned_rate',order_dimensions)]\n        let _endTime = _startTime.add(duration, 'hours')\n\n        //handle changeover\n        let changeover_duration = order[findIndex('planned_changeover_time',order_dimensions)]\n        if (changeover_duration !== '0:00:00'){ \n\n          //if the order has changeover time\n          changeover_duration = moment.duration(changeover_duration)\n          let changeover = utils.copyObject(order)\n          changeover[1] = currentStartTime // changeover's start time = current start time\n          changeover[2] = moment(currentStartTime).add(changeover_duration).valueOf() // changeover's end time = main order's start time\n          changeover[8] = 'Changeover' // set statuts to be changeover\n\n          order_data.push(changeover)\n\n          //update the order's startTime and endTime\n          order[1] = moment(currentStartTime).add(changeover_duration).valueOf()\n          order[2] = _endTime.add(changeover_duration).valueOf()\n        }else {\n          //update the order's startTime and endTime\n          order[1] = currentStartTime\n          order[2] = _endTime.valueOf()\n        }\n  \n        //update each order to the database\n        const line = writeLine(utils.mergeKeyVal(order, order_dimensions))\n        promises.push(utils.post(influxUrl, line))\n      }\n    }\n  }\n\n  if (promises.length > 0) {\n    //do nothing if requests are successful, popup the error if failed.\n    Promise.all(promises).then(res => {\n      chartCtrl.refreshDashb()\n    }).catch(e => {\n      utils.alert('error', 'Influxdb Error', 'An error occurred while updating data : ' + e)\n    })\n  }\n\n  //set order data and its dimension global because it will be required later from other files\n  _order_data = order_data\n  _order_dimensions = order_dimensions\n\n  // Echart automatically convert number String to Int, so need to add some extra non-num String to avoid this\n  // Will need to String.replace('###', '') when use it\n  order_data.forEach(e => {\n    const product_id_api = e[findIndex('product_id', order_dimensions)] + '###'\n    e.push(product_id_api)\n  })\n  order_dimensions.push('product_id_api')\n\n  //return the expect option data\n  return {\n    order: {data: order_data, dimensions: order_dimensions},\n    line: {data: line_data, dimensions: line_dimensions}\n  }\n}\n\nfunction matchIndex(key, lines){\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (key === line[3]) {\n      return line[2]\n    }\n  }\n  return -1\n}\n\nfunction takeOfKeys(data) {\n  return data.map( Object.values )\n}\n\n/**\n * Expecting an array of arrays, categorise the inner arrays by line\n */\nfunction categoriseByLineAndDate(data, key, obj){\n  let result = []\n  \n  for (let i = 0; i < data.length; i++) {\n    const elem = data[i];\n    const objdata = obj[i]\n    \n    let dates = obj.filter(d => d.production_line === objdata.production_line).map(d => d.order_date)\n    dates = Array.from(new Set(dates))\n    const dateIndex = findIndex(objdata.order_date, dates)\n    \n    if (result[objdata.index]) {\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }else {\n      result.push([])\n      if (result[objdata.index][dateIndex]) {\n        result[objdata.index][dateIndex].push(elem)\n      }else{\n        result[objdata.index].push([])\n        result[objdata.index][dateIndex].push(elem)\n      }\n    }\n  }\n\n  return result\n}\n\nexport function findIndex(key, array){\n  return array.indexOf(key)\n}\n\nfunction writeLine(data){  \n  //For influxdb tag keys, must add a forward slash \\ before each space   \n  let product_desc = data.product_desc.split(' ').join('\\\\ ')\n  \n  let line = 'OrderPerformance,order_id=' + data.order_id + ',product_id=' + data.product_id + ',product_desc=' + product_desc + ' '\n\n  if (data.compl_qty !== null && data.compl_qty !== undefined) {\n    line += 'compl_qty=' + data.compl_qty + ','\n  }\n\n  line += 'order_state=\"' + data.status + '\"' + ','\n  line += 'order_date=\"' + data.order_date + '\"' + ','\n  line += 'production_line=\"' + data.production_line + '\"' + ','\n  line += 'planned_changeover_time=\"' + data.planned_changeover_time + '\"' + ','\n  line += 'order_qty=' + data.order_qty + ','\n  line += 'scheduled_end_datetime=' + data.endTime + ','\n  line += 'scheduled_start_datetime=' + data.startTime + ','\n  line += 'setpoint_rate=' + 0 + ','\n  line += 'planned_rate=' + data.planned_rate\n\n  return line\n}\n\nexport function getColor(status){\n  let color\n  switch (status) {\n    case 'Changeover':\n      color = '#c9c52a'\n      break;\n    case 'Planned':\n      color = '#c9c9c9'\n      break;\n    case 'Ready':\n      color = '#CCFFAF'\n      break;\n    case 'Next':\n      color = '#FFFB85'\n      break;\n    case 'Paused':\n      color = '#E8B20C'\n      break;\n    case 'Complete':\n      color = '#70C6FF'\n      break;\n    case 'Closed':\n      color = '#FF7773'\n      break;\n    case 'Running':\n      color = '#91F449'\n      break;\n    default:\n      color = '#fff'\n      break;\n  }\n  return color\n}\n\nexport function getData(){\n  return utils.mergeKeyArrayVal(_order_data, _order_dimensions).filter(order => order.status !== 'Changeover')\n}"]}